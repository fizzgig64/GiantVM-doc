# Intel IA32 Manual Chapter 10 APIC

## Overview

Local APIC (hereinafter referred to as APIC) can receive interrupts from the following sources:

1. The local interrupt received through the two pins LINT0 and LINT1
2. External interrupt received via IOAPIC
3. IPI from other CPUs (or even yourself)
4. Interrupts generated by APIC Timer
5. Interrupts caused by APIC internal errors
6. Interrupts generated by Performance Monitoring Counter (cf 18.6.3.5.8)
7. Interrupts generated by the temperature sensor (cf 14.7.2)

Among them, 1, 4, 5, 6, 7 are collectively referred to as local interrupt sources, and their reception is controlled through the LVT (Local Vector Table). By writing to the Interrupt Control Register (ICR), you can send IPI. IOAPIC sends interrupts to APIC through interrupt messages. The Interrupt Vector has been specified in the message, so APIC does not need to be configured through the LVT table.

In the era of P6 family (from Pentium Pro to Pentium 3), the APIC of each CPU communicated through an APIC bus, and both IPI message and interrupt message were transmitted on this bus. Starting from Pentium 4, the communication between APICs has been changed to the system bus, and the interrupt message sent by IOAPIC is also sent to APIC via the system bus.
> **Note:** There are some unique settings for Pentium and P6 family in APIC. The following are all marked with: warning:. Some of them involve its unique APIC Bus. If you are interested, please refer to sections 10.7, 10.10, and 10.13 of the manual for comparison and understanding.

APIC was originally derived from the external Intel 82489DX chip, and evolved into APIC in the era of Pentium and P6. Since Pentium 4, it has further evolved into xAPIC, and in recent years has expanded to x2APIC, providing more functions.

## Basic functions

### Overview

APIC registers are accessed through MMIO, and the corresponding physical address is 4KB pages starting from 0xFEE00000. For the specific mapping relationship of the registers, see Table 10-1 of the manual. Judge whether the CPU supports APIC and x2APIC can be realized by querying CPUID.

> **Info:** The physical address of the page where the register is located can be changed by setting. This is an ancient feature left over from the P6 era. At that time, it was to prevent conflicts with programs that have already used this address, and it is no longer used. Also note that the page must be set to strong uncacheable (UC) in the page table.

APIC can be disabled/enabled by hardware. Disabling and enabling it is equivalent to restarting after a power failure. In addition, you can also [software disable/enable](#spurious-interrupt), which is only temporarily disabled, and its status will be retained after re-enable. It should be noted that APIC is in the software disabled state by default after power on.

### APIC MSR

The only MSR related to APIC is `IA32_APIC_BASE`:

-The 8th bit represents whether the CPU is a BSP (1 represents BSP)
-The 11th bit can be used to enable/disable APIC by hardware (0 means disable, it can still be enabled after being disabled since Pentium 4, but not on P6). After disabling, it means that APIC does not exist, and CPUID will also show that APIC is not supported. Re-enable Then APIC returns to the state when the power is turned off
-Bits 12-35 represent the APIC Base, which is the physical address of the APIC register (the actual physical address is the APIC Base shifted to the left by 12 bits, which means exactly 4K alignment) **[Note: This feature is only for compatibility]**

### Local APIC ID Register

Located at Base + 0x20, it is used as the ID of the CPU. Its initial value is automatically determined and assigned by the hardware when booting. It will be used by the BIOS and/or OS, so it should not be modified (and only supported on some models of CPU). If the value has been changed, the initial value can still be queried through `CPUID.01H.EBX[31:24]`.

Pentium and P6 family only use bits 24-27 (4 bits in total), so they support up to 15 CPUs. The xAPIC mode starting from Pentium 4 uses bits 24-31 (8 bits in total), so it supports up to 255 CPUs. x2APIC uses the 32-bit x2APIC ID, which is stored in the MSR, and it can be considered that there is no limitation on the maximum number of CPUs.

### Local APIC Version Register

Located at Base + 0x30, read-only, functions are as follows:

-Bits 0-7 are Version Number
-Bits 16-23 are Max LVT Entry, and its value is the maximum LVT number -1
-The 24th bit indicates whether to support [Suppress EOI-broadcast](#spurious-interrupt-vector-register)

## Handling Local Interrupts

### Local Vector Table

There are a total of (up to) seven items in the LVT table, each of which is responsible for configuring the distribution of interrupts from one source. They are:

-LVT CMCI Register, Base + 0x2F0
    -Responsible for sending Corrected Machine Check Error Interrupt, that is, after the corrected Machine Check Error accumulates to more than a threshold, it will cause a CMCI interrupt (this is only available from Xeon 5500, this function is disabled by default)
-LVT Timer Register, Base + 0x320
    -Responsible for sending interrupts generated by APIC Timer
-LVT Thermal Monitor Register, Base + 0x330
    -Responsible for sending interrupts generated by the temperature sensor (this is only available from Pentium 4)
-LVT Performance Counter Register, Base + 0x340 (this address is for reference only, where the register is implementation specific)
    -Responsible for sending the interrupt generated by the performance counter Overflow (this is only available from the P6 family)
-LVT LINT0 Register, Base + 0x350
    -Responsible for forwarding interrupts from the LINT0 pin
-LVT LINT1 Register, Base + 0x360
    -Responsible for forwarding interrupts from the LINT1 pin
-LVT Error Register, Base + 0x370
    -Responsible for the interrupt generated when the APIC internal error is sent

The functions of these registers are as follows:

-Bits 0-7 are Vector, which is the interrupt vector number received by the CPU. Numbers 0-15 are considered illegal and an Illegal Vector error will be generated (ie bit 6 of ESR, [detailed below](#error-handling ))
-Bits 8-10 are Delivery Mode, with the following values:
    -000 (Fixed): Send the corresponding interrupt vector number to the CPU according to the value of Vector
    -010 (SMI): Send an SMI to the CPU, Vector must be 0 in this mode
    -100 (NMI): Send an NMI to the CPU, at this time Vector will be ignored
    -111 (ExtINT): Make the CPU respond to the interrupt in the same way as the external 8259A. This will cause an INTA cycle, during which the CPU will request the Vector from the external controller.
        -APIC only supports one ExtINT interrupt source, and there should be only one LVT table entry of one CPU configured in ExtINT mode in the entire system
-The 12th bit is Delivery Status (read only), 0 means idle, 1 means the CPU has not accepted the interrupt (not yet EOI)
-The 13th place is Interrupt Input Pin Polarity, 0 means active high, 1 means active low
-The 14th bit is the Remote IRR Flag (read only). If the currently accepted interrupt is fixed mode and level triggered, then this bit is 1 indicating that the CPU has accepted the interrupt (the interrupt has been added to the IRR), but has not yet performed EOI. After the CPU executes the EOI, this bit returns to 0.
-The 15th digit is Trigger Mode, 0 means edge triggered, 1 means level triggered (there are a lot of attention points in specific usage, see section 10.5.1 of the manual for details)
-The 16th bit is Mask, 0 means accepting interrupts is allowed, 1 means forbidden, the initial value is 1 after reset
-Bits 17/17-18 are Timer Mode, only available in LVT Timer Register, used to switch the three modes of APIC Timer, as detailed below

Note that not every register in LVT has all fields, the specific situation is as follows:

![local_vector_table](/assets/local_vector_table.png)

### Error Handling

When an internal error occurs in APIC, the cause of the error will be recorded in the Error Status Register (ESR), located at Base + 0x280, and the content is as follows:

-:warning: Bit 0: Send Checksum Error, only valid on Pentium and P6 family, **no need to consider it is outdated**
-:warning: Bit 1: Receive Checksum Error, only valid on Pentium and P6 family, **no need to consider it is outdated**
-:warning: Bit 2: Send Accept Error, only valid on Pentium and P6 family, **no need to consider it is outdated**
-:warning: Bit 3: Receive Accept Error, only valid on Pentium and P6 family, **outdated, no need to consider**
-Bit 4: Redirectable IPI, trying to send a Lowest Priority Mode IPI, but the CPU does not support it
    -Only some models will use this bit. Since the ability to send Lowest Priority Mode IPI depends on the specific model, it is not recommended for BIOS and OS to use this function.
-Bit 5: Send Illegal Vector, trying to send (via IPI) an Interrupt Vector in the range of 0-15
-Bit 6: Receive Illegal Vector, an Interrupt Vector in the range of 0-15 is received, including receiving from its own LVT and receiving IPI or external interrupts through Interrupt Message
-Bit 7: Illegal Register Address, trying to read a non-existent Register

Before reading the content of the ESR, you must write 0 to it to clear the previous flag, and automatically fill in the new flag, and reactivate the error detection mechanism.

### APIC Timer

APIC Timer is a 32-bit Timer, implemented by two 32-bit Counter registers:

-Initial Count Register, Base + 0x380
-Current Count Register, Base + 0x390 (read only)

The counter frequency is obtained by dividing the reference frequency of the APIC Timer by the divisor determined by the Divide Configuration Register. Divide Configuration Register, located in Base + 0x3E0, its 0th, 1st and 3rd bits determine the divisor:

![divider](/assets/divide_configuration_register.png)

> **Info:** APIC Timer may stop running when CPU sleeps. Check `CPUID.06H.EAX.ARAT[bit 2]` (APIC Timer Always Running bit) to know whether it will keep running forever. The reference frequency of APIC Timer is the bus frequency (external frequency) or Core crystal frequency (if it can be found through `CPUID.15H.ECX`).

APIC Timer has three operation modes, which can be set through bits 17-18 of the LVT Timer Register, which are:

-One shot (00): Write the Initial Count to start the Timer, the Current Count will continue to decrease from the Initial Count until it finally drops to zero to trigger an interrupt and stop changing
-Periodic (01): Write Initial Count to restart the Timer, Current Count will repeatedly decrease from Initial Count to 0, and trigger an interrupt when it decreases to 0
-TSC-Deadline Mode (10)
    -`CPUID.01H.ECX.TSC_Deadline[bit 24]` indicates whether the TSC-Deadline mode is supported, if not, the 18th bit is reserved
    -In this mode, writing to Initial Count will be ignored, and Current Count will always be 0. At this time, the Timer is controlled by MSR `IA32_TSC_DEADLINE_MSR`. Write a non-zero 64-bit value to it to activate the Timer, so that an interrupt is triggered when the TSC reaches this value. This interrupt will only be triggered once, and `IA32_TSC_DEADLINE_MSR` will be reset to zero after being triggered.
    > **Note:** Writing into the LVT Timer Register to switch to TSC-Deadline Mode is a Memory operation. A `MFENCE` must be added between this operation and the following `WRMSR` instruction to ensure that there is no disorder

Note that in the first two modes, writing 0 to Initial Count can stop the Timer operation, and in the third mode, writing 0 to `IA32_TSC_DEADLINE_MSR`. In addition, the modification mode will also stop the Timer operation. Of course, you can also use the Mask in the LVT Timer Register to mask the Timer interrupt to achieve the same effect.

## Handling Interrupts

### Interrupt Acceptance for Fixed Interrupts

The registers related to receiving interrupts are mainly Interrupt Request Register (IRR) and In-Service Register (ISR), both of which are 256 bits wide, and each bit represents an Interrupt Vector. IRR is located at Base + 0x200 to Base + 0x270 (a total of 8 32-bit registers), and ISR is located at Base + 0x100 to Base + 0x170 (a total of 8 32-bit registers).

The Fixed Interrupts received by APIC first enter the IRR and write the corresponding bit to indicate the interrupts that have been received but not yet sent to the CPU. When the CPU is ready to receive a new interrupt, APIC selects the interrupt with the highest priority (ie the largest Vector) in the IRR, clears its bit, sets the corresponding bit in the ISR, and sends it to the CPU.

When the CPU finishes executing the current interrupt processing routine, write 0 to the EOI Register (located at Base + 0xB0) (write non-zero seems to cause #GP, but the manual is not written), so as to clear the highest priority in the ISR (ie Vector is the largest interrupt bit.

When the CPU is processing an interrupt, it can be interrupted by a higher priority interrupt. If the Priority Class of the new interrupt received in the IRR is higher than the current Priority Class of the CPU (see the next section), it can be directly sent to the CPU and written to the ISR to interrupt the running interrupt processing routine (of course, the CPU must There is no off interrupt).

> **Info:** When receiving an interrupt whose Priority Class is less than or equal to the current Priority Class of the CPU, if there is still a space in the IRR, it can be placed in the IRR, even if the Vector in the ISR already occupies a position. That is to say, APIC supports two pending interrupts for the same Vector. In contrast, PIC only supports one pending interrupt for the same Vector (that is, the In-Service one).

In addition, there is a Trigger Mode Register (TMR), which is also 256 bits wide, and each bit represents an Interrupt Vector. When an interrupt comes, in addition to adding it to the IRR, the corresponding bit in the TMR will be set according to whether it is Level Triggered. 1 represents Level Triggered. The Level Triggered interrupt will broadcast the EOI Message to all IOAPICs via the bus after the CPU writes the EOI Register.
> **Info:** This default broadcasting behavior can be prohibited. Broadcasting to IOAPIC can be prohibited by setting the 12th bit of [Spurious Interrupt Vector Register](#spurious-interrupt-vector-register). At this point, the software must manually set the EOI Register of the IOAPIC that sends the interrupt to complete the necessary steps of EOI.

### Interrupt, Task, and Processor Priority

In the manual, the upper 4 bits of Interrupt Vector are called Interrupt Priority Class, and the lower 4 bits have no special title. The priority between Interrupt depends solely on its numerical value, the larger one means the higher priority.

Whether the interrupt currently being processed by the CPU can be interrupted by a new interrupt depends on the following two registers:

-Task Priority Register (TPR), located in Base + 0x80, bits 4-7 are Task Priority Class, and bits 0-3 are Task Priority Sub-Class.
    > **Info:** In IA32-e (ie x86-64) mode, there is CR8 register, and the 0-3 bits of it also represent Task Priority Class. At this time, there is always TPR[7:4] = CR8[3:0], but the OS should choose an operation mode between TPR and CR8, instead of mixing the two methods.
-Processor Priority Register (PPR), located at Base + 0xA0, bits 4-7 are Processor Priority Class, and bits 0-3 are Processor Priority Sub-Class.

Their meaning is as follows:

- Processor Priority Class represents the current Priority Class of the CPU. Only new interrupts whose Interrupt Priority Class is greater than it are allowed to be injected into the CPU and enter the ISR from the IRR. The Processor Priority Sub-Class has no practical effect.
- PPR is a read-only value determined by TPR and ISRV, where ISRV is the largest Vector in ISR (ISR is 0, ISRV is also 0). The formula is as follows:
    - `PPR[7:4] = max(TPR[7:4], ISRV[7:4])`
    - PPR[3:0] has no practical effect, so it is omitted

In other words, the priority mechanism is actually that every 16 Interrupt Vectors are divided into a group (Class), and the last 16 have higher priority than the first 16. Task Priority indicates that the CPU wants to (temporarily) block interrupts of the Priority Class and below. In addition, the interrupt currently being processed by the CPU can only be interrupted by an interrupt higher than the highest Priority Class in the ISR.

### Summary: Pentium 4 and Xeon processing flow

1. Confirm whether you are the target of Interrupt Message, if so, continue
2. If the received interrupt is NMI, SMI, INIT, ExtINT or SIPI, it will be directly handed over to the CPU for processing
3. Otherwise set the appropriate bit in the IRR
4. For interrupts pending in IRR, APIC distributes them in sequence according to their priority and the current CPU priority (in the PRR), and only one interrupt is given to the CPU at a time
5. When the interrupt processing routine is executed, the EOI Register should be written so that APIC deletes the corresponding item from the ISR queue and ends the interrupt processing (NMI, SMI, INIT, ExtINT and SIPI do not need to be written to EOI)

## Spurious Interrupt Vector Register

The reason for Spurious Interrupt is as follows: When the CPU wants to receive an ExtINT interrupt, the first step is to obtain the interrupt vector number. It takes two cycles. The first cycle receives the signal from the INTR pin, and the second cycle (INTA cycle) is from the outside. The controller obtains the interrupt vector number. The usual interrupts are to obtain the interrupt vector number during the period when the INTR pin receives the signal. Due to this non-atomicity, if the CPU happens to mask the ExtINT interrupt through the LVT entry in the INTA cycle, APIC will send a Spurious Interrupt instead.

Spurious-Interrupt Vector Register (SVR), located at Base + 0xF0, the content is as follows:
-Bits 0-7 are Spurious Vector, which is the Interrupt Vector that should be sent when APIC generates Spurious Vector
    -For Pentium and P6 family, bits 0-3 are hardwired to 1, so the lower 4 bits of Spurious Vector are best set to all 1s
-The 8th bit controls APIC software enable/disable, 1 is enable, 0 is disable
    -After the APIC is powered off and restarted, the software is disabled by default
    -When the software is disabled, the status of IRR and ISR will remain
    -In the software disabled state, it can still respond to NMI, SMI, INIT, SIPI interrupts, and can still send IPI through ICR
    -In the software disabled state, the Mask bit of the LVT entry is forcibly set to 1 (ie masked)
-:warning: The 9th digit is Focus Processor Checking, 1 means to disable Focus Processor, and 0 means to enable. Focus Processor is a concept that Pentium and P6 family will involve when dealing with Lowest Priority Mode. **Now it is no longer useful**
-The 12th bit is Suppress EOI Broadcasts, set to 1 to prohibit a Level Triggered interrupted EOI by default to broadcast EOI Message to IOAPIC
    > **Info:** Not all models of CPU support this function. Check the 24th bit of the APIC Version Register to see if it supports it.

## Issuing IPIs

### Interrupt Command Register (ICR)

ICR is a 64-bit register, divided into two parts, ICR_Low and ICR_High, which are located in Base + 0x300 (Low) and Base + 0x310 (High) respectively. Write ICR_Low to send an IPI.
> **Info:** The content of ICR_Low may be lost after entering deep sleep C-State

The content of ICR_Low is as follows:

-Bits 0-7 are Vector, which is the interrupt vector number received by the target CPU. Numbers 0-15 are considered illegal and an Illegal Vector error will be generated to the APIC of the target CPU (ie bit 6 of ESR)
-Bits 8-10 are Delivery Mode, with the following values:
    -000 (Fixed): Send the corresponding interrupt vector number to the target CPU(s) according to the value of Vector
    -001 (Lowest Priority): According to the value of Vector, send the corresponding interrupt vector number to the CPU with the lowest Priority among all target CPU(s) determined by Destination ([detailed below](#lowest-priority-mode))
        > **Info:** The ability to send IPI in Lowest Priority mode depends on the CPU model and is not always valid, so BIOS and OS should not send IPI in Lowest Priority mode
    -010 (SMI): Send an SMI to the target CPU(s), Vector must be 0 in this mode
    -100 (NMI): Send an NMI to the target CPU(s), at this time Vector will be ignored
    -101 (INIT): Send an INIT IPI to the target CPU(s), causing an INIT to occur on the CPU (refer to Table 9-1 of the manual for CPU status after INIT). In this mode, Vector must be 0
        > **Info:** The APIC ID and Arb ID of the CPU after INIT (only exists on Pentium and P6) remain unchanged
    -:warning: 101 (INIT Level De-assert): Broadcast a special IPI to all CPUs, reset the Arb ID of all CPU APICs (existing only on Pentium and P6) to the initial value (initial APIC ID). To use this mode, Level must be 0, Trigger Mode must be 1, and Destination Shorthand must be set to All Including Self.
        -Only valid on Pentium and P6 family, **no need to consider obsolete**
    -110 (Start-up): Send a Start-up IPI (SIPI) to the target CPU(s), the target will start execution from 0x000VV000, where 0xVV is the value of Vector
-The 11th bit is Destination Mode, 0 means Physical, 1 means Logical ([detailed below](#determining-ipi-destination))
-The 12th bit is Delivery Status (read only), 0 means idle, 1 means the last IPI has not been sent yet
-:warning: The 13th bit is Level, if 0 is set, Delivery Mode 101 means INIT Level De-assert, otherwise it means INIT.
    -Only meaningful on Pentium and P6 family, **This bit must always be 1 on Pentium 4 and later CPUs**
-:warning: The 14th bit is Trigger Mode, which means the trigger mode in INIT Level De-assert mode, 0 means edge triggered, and 1 means level triggered.
    -Only meaningful on Pentium and P6 family, **This bit must always be 0 on Pentium 4 and later CPUs**
-The 18th-19th digits are Destination Shorthand. If Shorthand is specified, there is no need to specify the target CPU through the Destination field in ICR_High, so you can send IPI once by writing to ICR_Low once. The value of this field is as follows:
    -00 (No Shorthand): The target CPU is specified by Destination
    -01 (Self): The target CPU is itself
    -10 (All Including Self): Broadcast IPI to all CPUs. The Destination of the IPI Message sent at this time will be set to 0xF (Pentium and P6) or 0xFF (Pentium 4 and later), which means it is a global broadcast
    -11 (All Excluding Self): Same as above, except not sending to self

ICR_High has only 56-63 bits valid, which is used to indicate the Destination. It determines the target CPU(s) sent by the IPI. See the next section for how to decide.

### Determining IPI Destination

#### Physical Destination Mode

If the Destination Mode is 0, it is the Physical mode. In this mode, the Destination field represents the APIC ID of the target CPU, and 0xF (Pentium and P6) or 0xFF (Pentium 4 and later) represents global broadcast.

#### Logical Destination Mode

If the Destination Mode is 1, it is Logical mode. In this mode, the Destination field represents the Message Destination Address (MDA). After the IPI Message is sent to the bus, the APIC of each CPU will decide whether to accept this IPI according to its Logical Destination Register (LDR) and Destination Format Register (DFR).

Logical Destination Register, located at Base + 0xD0, the 24-31th bits represent Logical APIC ID

Destination Format Register, located at Base + 0xE0, its 28th-31th bits represent Model, 0000 represents Cluster Model, and 1111 represents Flat Model.
> **Note:** The DFR of all (software) enabled APICs must be set to the same mode. The DFR should be set as early as possible (in the early stage of startup), and should be set after the DFR mode is set ( Software) enable APIC

##### Flat Model

APIC performs an AND operation between its own LDR and the MDA of the IPI Message on the bus. If the result is non-zero, the IPI is accepted

##### Cluster Model [Should be used for NUMA, it is not recommended to use this mode casually]

-:warning: Flat Cluster mode, only supported by Pentium and P6 family
    -LDR and MDA are divided into two parts respectively. The upper 4 bits represent the Cluster. Only the upper 4 bits of LDR and MDA are completely equal to belong to the cluster. The lower 4 bits can be further compared, and the lower 4 bits are used to select a specific APIC. If LDR A non-zero result of `AND` with the lower 4 bits of MDA indicates acceptance.
    -Cluster 15 means broadcasting to all Clusters, so it only supports a total of 15 Clusters from 0 to 14. MDR takes 0xFF to realize global broadcasting.
-Hierarchical Cluster mode, all models support
    -The system is divided into several Clusters, with a maximum of 15 Clusters. Each Cluster needs a special hardware called Cluster Manager. Each Cluster can have up to 4 Agents, and a total of up to 60 APIC Agents.
    -The specific addressing method is not explained in the manual. From the above description, it seems that the addressing method is the same as the Flat Cluster, but the hardware structure is different. (The manual does not mention any software method to switch these two modes, so the addressing method is considered the same Is reasonable)

#### Lowest Priority Mode

When using Logical Destination Mode or Destination Shorthand for IPI group sending, Lowest Priority Mode can be used to select the CPU with the lowest priority in the target CPU set as the sending object, and finally only this CPU can receive IPI.

In Xeon and later CPUs, the selection is made automatically through the motherboard chipset, and the CPU may not be able to interfere [more investigation #TODO# is needed]. On Pentium 4, the chipset can obtain the Task Priority of the CPU through a special bus cycle (it seems to be TPR[7:0] [doubt]), so that when arbitration is required, the CPU with the lowest priority is selected.

On Pentium and P6 family, arbitration relies on Arbitration Priority Register (APR, located at Base + 0x90), and its value is as follows:

```
if (TPR[7:4] >= IRRV[7:4] && TPR[7:4]> ISRV[7:4]) {
    APR[7:0] = TPR[7:0]
} else {
    APR[7:4] = max(TPR[7:4], ISRV[7:4], IRRV[7:4])
    APR[3:0] = 0
}
```

Among them, ISRV is the largest Vector in ISR, and IRRV is the largest Vector in IRR. The CPU with the smallest APR wins and gets IPI.

> **Note:** In addition to IPI, interrupts sent by IOAPIC can also be in Lowest Priority Mode, and interrupts sent via MSI can also be in Lowest Priority Mode. When this feature was originally designed, it should be used in conjunction with TPR. Whenever the OS switches Task (process/thread/etc.), update TPR (Task Priority) so that high-priority tasks are not interrupted by interrupts. Give priority to low-priority tasks.

## Message Signalled Interrupts
The sending of MSI is realized by a PCI write transaction to a special address (representing the target CPU). When a PCI device wants to send an interrupt, it will read the destination address of the interrupt from its Message Address Register (and Message Upper Address Register, if the address is 64 bits), and fill it in from the Message Data Register Interrupt the content of the Message. The two registers are described below:

Message Address Register:

-Bits 20-31, must be 0xFEE
-The 12th to 19th digits are the Destination ID, which is equivalent to the 56th to 63rd digits of RTE in IOAPIC, and also equivalent to the Destination in ICR_High
-The third place is Redirection Hint Indication (RH), 0 is equivalent to fixed mode, and 1 is equivalent to lowest priority mode
    -When RH is set to 1, and DM is set to 0, the Destination is not allowed to take 0xFF, and other values ​​can be sent to the Physical Destination normally
    -When RH is 1, DM is 1, and the Clustered Addressing Model is used, Destination is not allowed to be 0xFF, that is, global broadcast is not allowed
-The second bit is Destination Mode (DM), 0 means Physical Mode, 1 means Logical Mode

Message Data Register:

-Bits 0-7 are Vector, which is the interrupt vector number received by the target CPU. Numbers 0-15 are considered illegal and an Illegal Vector error will be generated to the APIC of the target CPU (ie bit 6 of ESR)
-Bits 8-10 are Delivery Mode, with the following values:
    -000 (Fixed): Send the corresponding interrupt vector number to the target CPU(s) according to the value of Vector
    -001 (Lowest Priority): Send the corresponding interrupt vector number to the CPU with the lowest Priority among all target CPU(s) determined by Destination according to the value of Vector
    -010 (SMI): Send an SMI to the target CPU(s). In this mode, Vector must be 0, and SMI must be edge triggered
    -100 (NMI): Send an NMI to the target CPU(s) (take the #NMI pin), at this time Vector will be ignored, NMI is always edge triggered, no matter what Trigger Mode is set to
    -101 (INIT): Send an INIT IPI to the target CPU(s), causing an INIT to occur on the CPU. At this time, the Vector will be ignored, and the INIT will always be edge triggered, no matter what Trigger Mode is set to
    -111 (ExtINT): Sending an interrupt signal compatible with 8259A to the target CPU(s) will cause an INTA cycle. The CPU(s) will request the Vector from the external controller during this cycle. ExtINT must be edge triggered
-The 14th bit is Level. If the interrupt is level triggered, then 1 means Assert, and 0 means Deassert
-The 15th bit is Trigger Mode, 0 means edge triggered, 1 means level triggered

## Extended XAPIC (x2APIC)
Set bit 10 of `IA32_APIC_BASE` MSR to 1 to enable x2APIC. After power off and restart, the first entry is xAPIC mode, and then x2APIC mode. Once entered, it cannot return to xAPIC mode (otherwise it will cause #GP), and a restart (hardware disable and then enable) is required to return to xAPIC mode.

> **Info:** INIT in x2APIC mode returns to the initial state of x2APIC mode instead of xAPIC mode. Similarly, INIT in xAPIC mode returns to the initial state of xAPIC mode. It is not allowed to enable x2APIC mode while the hardware is disabled (attempting to do so will cause #GP). INIT is still disabled when the hardware is disabled.

> Before starting x2APIC mode, BIOS should also check and enable Extended Interrupt Mode in VT-d

In x2APIC mode, its registers are accessed through MSR. MSRs from 0x800 to 0x8FF are reserved for x2APIC. These MSRs cannot be accessed before entering x2APIC mode, otherwise #GP will be caused. Similarly, after entering x2APIC mode, the MMIO area of xAPIC is equivalent to the state when it is closed.

Compared with xAPIC, x2APIC registers basically correspond to each other (MSR is 64-bit wide, but only corresponds to the 32-bit xAPIC register, and the upper 32 bits are reserved), except for the following changes:

-Canceled the DFR register
-ICR_Low and ICR_High are combined into a 64-bit register ICR (MSR 0x830)
-Added SELF IPI register (MSR 0x83F)

### x2APIC ID

APIC ID has been changed to 32 bits, and the expanded ID can be called x2APIC ID, which occupies 32 bits of APIC ID Register. The register is changed to read-only and will only be set once by the hardware at boot time, and the last 8 bits are used as APIC ID in xAPIC mode.

> **Info:** In the actual implementation, the x2APIC ID may be less than 32 bits. At this time, the unsupported high bit is always 0. The actual range can be determined by writing 0xFFFFFFFF and then reading.

If x2APIC mode is supported, a complete 32-bit x2APIC ID can be obtained through `CPUID.0BH.EDX`, which helps BIOS to determine that the system's APIC ID exceeds the upper limit of 256 in xAPIC mode. If it really exceeds the upper limit, the BIOS must (a) enable x2APIC mode on all CPUs before entering the OS or (b) only enable CPUs with APIC IDs less than or equal to 255 (other CPUs put them into deep sleep to ensure that they are not OS starts) and remains in xAPIC mode.

### ICR Operation

The lower 32 bits of ICR are the same as the original ICR_Low (except for the cancellation of the Delivery Status bit), and the upper 32 bits of the Destination Field have been expanded from 8 bits to 32 bits.

Destination 0xFFFFFFFF means broadcast regardless of whether it is in Physical or Logical mode. The semantics in Physical mode are obvious, and the changes in Logical mode are discussed below.

The effective content of LDR is expanded from 8 bits to 32 bits and becomes read-only. Its value can be called Logical x2APIC ID. In the x2APIC mode, the Flat Model is cancelled, so according to the Clustered Model, the Logical x2APIC ID is divided into the high 16-bit Cluster ID and the low 16-bit Logical ID. The former matches the high 16 bits of Destination, and the latter calculates `AND` with the low 16 bits of Destination.

In fact, the Logical x2APIC ID is determined by the x2APIC ID during initialization, and the calculation method is `Logical x2APIC ID = (x2APIC ID[19:4] << 16) | (1 << x2APIC ID[3:0])`.

### Self IPI Register

This register is a write-only register. Attempting to read it will cause #GP. Only bits 0-7 are valid, which represents the Interrupt Vector. The effect of writing this register is equivalent to sending an Edge Triggered, Fixed Interrupt Self IPI by writing ICR.
